;; The first three lines of this file were inserted by DrRacket. They record metadata
;; about the language level of this file in a form that our tools can easily process.
#reader(lib "htdp-intermediate-lambda-reader.ss" "lang")((modname play-sudoku) (read-case-sensitive #t) (teachpacks ()) (htdp-settings #(#t constructor repeating-decimal #f #t none #f () #f)))
(require racket/list) ;gets list-ref, take and drop
(require spd/tags)

;; PLAYABLE SUDOKU GAME by Ellen Lloyd
;;
;; Based on Constrained Search Tree Sudoku solver
;; Solution Design by Ellen Lloyd
;;
;; In Sudoku, the board is a 9x9 grid of SQUARES.
;; There are 9 ROWS and 9 COLUMNS, there are also 9
;; 3x3 BOXES.  Rows, columns and boxes are all UNITs.
;; So there are 27 units.
;;
;; The idea of the game is to fill each square with
;; a Natural[1, 9] such that no unit contains a duplicate
;; number.
;;

;; =================
;; Data definitions:

(@htdd Val)
;; Val is Natural[1, 9]

(@htdd Board)
;; Board is (listof Val|false)   that is 81 elements long
;; interp.
;;  Visually a board is a 9x9 array of squares, where each square
;;  has a row and column number (r, c).  But we represent it as a
;;  single flat list, in which the rows are layed out one after
;;  another in a linear fashion. (See interp. of Pos below for how
;;  we convert back and forth between (r, c) and position in a board.)

(@htdd Pos)
;; Pos is Natural[0, 80]
;; interp.
;;  the position of a square on the board, for a given p, then
;;    - the row    is (quotient p 9)
;;    - the column is (remainder p 9)

;; Convert 0-based row and column to Pos
(define (r-c->pos r c) (+ (* r 9) c))  ;helpful for writing tests

(@htdd Unit)
;; Unit is (listof Pos) of length 9
;; interp. 
;;  The position of every square in a unit. There are
;;  27 of these for the 9 rows, 9 columns and 9 boxes.

;; -----------------
;; NEW Data definitions:

(@htdd Square)
;; Square is one of: Val or (listof Val)
;; If Val, represents a square with a filled-in number on the board
;; If (listof Val), represents possible Val that could be placed in this square
(define S1 3)
(define S2 (list 1 2 3 4 5 6 7 8 9))  ;all placements possible
(define S3 empty)  ;no valid placements
(define S4 (list 2 5 6 9))  ;4 possible placements

(@htdd SmartBoard)
;; SmartBoard is (listof Square) that is 81 elements long.
;; Interp. SmartBoard is just like Board but with extra information stored:
;; each unfilled "false" square is instead represented as a (listof Val) Square
;; that stores possible Vals. Squares in a SmartBoard can be accessed via Pos.


;; ===================
;; Original Constants:

(define ALL-VALS (list 1 2 3 4 5 6 7 8 9))

(define B false) ;B stands for blank

(define BD1   ;all blank
  (list B B B B B B B B B
        B B B B B B B B B
        B B B B B B B B B
        B B B B B B B B B
        B B B B B B B B B
        B B B B B B B B B
        B B B B B B B B B
        B B B B B B B B B
        B B B B B B B B B))
(define BD2   ;top row is 1-9
  (list 1 2 3 4 5 6 7 8 9 
        B B B B B B B B B 
        B B B B B B B B B 
        B B B B B B B B B 
        B B B B B B B B B
        B B B B B B B B B
        B B B B B B B B B
        B B B B B B B B B
        B B B B B B B B B))
(define BD3   ;left column is 1-9
  (list 1 B B B B B B B B
        2 B B B B B B B B
        3 B B B B B B B B
        4 B B B B B B B B
        5 B B B B B B B B
        6 B B B B B B B B
        7 B B B B B B B B
        8 B B B B B B B B
        9 B B B B B B B B))
(define BD4   ;easy
  (list 2 7 4 B 9 1 B B 5
        1 B B 5 B B B 9 B
        6 B B B B 3 2 8 B
        B B 1 9 B B B B 8
        B B 5 1 B B 6 B B
        7 B B B 8 B B B 3
        4 B 2 B B B B B 9
        B B B B B B B 7 B
        8 B B 3 4 9 B B B))
(define BD4s  ;solution to 4
  (list 2 7 4 8 9 1 3 6 5
        1 3 8 5 2 6 4 9 7
        6 5 9 4 7 3 2 8 1
        3 2 1 9 6 4 7 5 8
        9 8 5 1 3 7 6 4 2
        7 4 6 2 8 5 9 1 3
        4 6 2 7 5 8 1 3 9
        5 9 3 6 1 2 8 7 4
        8 1 7 3 4 9 5 2 6))
(define BD5   ;hard
  (list 5 B B B B 4 B 7 B
        B 1 B B 5 B 6 B B
        B B 4 9 B B B B B
        B 9 B B B 7 5 B B
        1 8 B 2 B B B B B 
        B B B B B 6 B B B 
        B B 3 B B B B B 8
        B 6 B B 8 B B B 9
        B B 8 B 7 B B 3 1))
(define BD5s  ;solution to 5
  (list 5 3 9 1 6 4 8 7 2
        8 1 2 7 5 3 6 9 4
        6 7 4 9 2 8 3 1 5
        2 9 6 4 1 7 5 8 3
        1 8 7 2 3 5 9 4 6
        3 4 5 8 9 6 1 2 7
        9 2 3 5 4 1 7 6 8
        7 6 1 3 8 2 4 5 9
        4 5 8 6 7 9 2 3 1))
(define BD6   ;hardest ever? (Dr Arto Inkala)
  (list B B 5 3 B B B B B 
        8 B B B B B B 2 B
        B 7 B B 1 B 5 B B 
        4 B B B B 5 3 B B
        B 1 B B 7 B B B 6
        B B 3 2 B B B 8 B
        B 6 B 5 B B B B 9
        B B 4 B B B B 3 B
        B B B B B 9 7 B B))
(define BD7   ; no solution 
  (list 1 2 3 4 5 6 7 8 B 
        B B B B B B B B 2 
        B B B B B B B B 3 
        B B B B B B B B 4 
        B B B B B B B B 5
        B B B B B B B B 6
        B B B B B B B B 7
        B B B B B B B B 8
        B B B B B B B B 9))

;; Positions of all the rows, columns and boxes:

(define ROWS
  (list (list  0  1  2  3  4  5  6  7  8)
        (list  9 10 11 12 13 14 15 16 17)
        (list 18 19 20 21 22 23 24 25 26)
        (list 27 28 29 30 31 32 33 34 35)
        (list 36 37 38 39 40 41 42 43 44)
        (list 45 46 47 48 49 50 51 52 53)
        (list 54 55 56 57 58 59 60 61 62)
        (list 63 64 65 66 67 68 69 70 71)
        (list 72 73 74 75 76 77 78 79 80)))
(define COLS
  (list (list 0  9 18 27 36 45 54 63 72)
        (list 1 10 19 28 37 46 55 64 73)
        (list 2 11 20 29 38 47 56 65 74)
        (list 3 12 21 30 39 48 57 66 75)
        (list 4 13 22 31 40 49 58 67 76)
        (list 5 14 23 32 41 50 59 68 77)
        (list 6 15 24 33 42 51 60 69 78)
        (list 7 16 25 34 43 52 61 70 79)
        (list 8 17 26 35 44 53 62 71 80)))
(define BOXES
  (list (list  0  1  2  9 10 11 18 19 20)
        (list  3  4  5 12 13 14 21 22 23)
        (list  6  7  8 15 16 17 24 25 26)
        (list 27 28 29 36 37 38 45 46 47)
        (list 30 31 32 39 40 41 48 49 50)
        (list 33 34 35 42 43 44 51 52 53)
        (list 54 55 56 63 64 65 72 73 74)
        (list 57 58 59 66 67 68 75 76 77)
        (list 60 61 62 69 70 71 78 79 80)))
(define UNITS (append ROWS COLS BOXES))


;; ===================
;; New tools and constants for representing SmartBoard

(define E empty)     ;E stands for empty (unsolveable Square in SmartBoard)
(define A ALL-VALS)  ;A stands for all (unfilled Square with all Val possible)

(@htdf ex)
(@signature (listof Val) -> (listof Val))
;; produce set difference of ALL-VALS and provided list of Val
(check-expect (ex (list)) ALL-VALS)
(check-expect (ex (list 2)) N2)
(check-expect (ex (list 8)) N8)
(check-expect (ex (list 4 5 6)) (list 1 2 3 7 8 9))

(@template use-abstract-fn)
(define (ex lov)
  (filter (lambda (v) (not (member v lov)))
          ALL-VALS))

(define N1 (filter (lambda (v) (not (= v 1))) ALL-VALS))  ;1 not allowed
(define N2 (filter (lambda (v) (not (= v 2))) ALL-VALS))  ;2 not allowed
(define N3 (filter (lambda (v) (not (= v 3))) ALL-VALS))  ;3 not allowed
(define N4 (filter (lambda (v) (not (= v 4))) ALL-VALS))  ;4 not allowed
(define N5 (filter (lambda (v) (not (= v 5))) ALL-VALS))  ;5 not allowed
(define N6 (filter (lambda (v) (not (= v 6))) ALL-VALS))  ;6 not allowed
(define N7 (filter (lambda (v) (not (= v 7))) ALL-VALS))  ;7 not allowed
(define N8 (filter (lambda (v) (not (= v 8))) ALL-VALS))  ;8 not allowed
(define N9 (filter (lambda (v) (not (= v 9))) ALL-VALS))  ;9 not allowed

(define N123 (list 4 5 6 7 8 9))  ;1 2 3 not allowed
(define N456 (list 1 2 3 7 8 9))  ;4 5 6 not allowed
(define N789 (list 1 2 3 4 5 6))  ;7 8 9 not allowed


;; -------------------
;; SmartBoard Examples

(define SB1  ;all blank i.e. list Squares each ALL-VALS
  (list A A A A A A A A A
        A A A A A A A A A
        A A A A A A A A A
        A A A A A A A A A
        A A A A A A A A A
        A A A A A A A A A
        A A A A A A A A A
        A A A A A A A A A
        A A A A A A A A A))
(define SB2-raw  ;top row is 1-9
  (list 1 2 3 4 5 6 7 8 9
        A A A A A A A A A
        A A A A A A A A A
        A A A A A A A A A
        A A A A A A A A A
        A A A A A A A A A
        A A A A A A A A A
        A A A A A A A A A
        A A A A A A A A A))
(define SB2
  (local [(define l list)]
    (list 1  2  3  4  5  6  7  8  9 
          N123 N123 N123 N456 N456 N456 N789 N789 N789
          N123 N123 N123 N456 N456 N456 N789 N789 N789
          N1 N2 N3 N4 N5 N6 N7 N8 N9 
          N1 N2 N3 N4 N5 N6 N7 N8 N9
          N1 N2 N3 N4 N5 N6 N7 N8 N9
          N1 N2 N3 N4 N5 N6 N7 N8 N9
          N1 N2 N3 N4 N5 N6 N7 N8 N9
          N1 N2 N3 N4 N5 N6 N7 N8 N9)))
(define SB3-raw  ;left column is 1-9
  (list 1 A A A A A A A A
        2 A A A A A A A A
        3 A A A A A A A A
        4 A A A A A A A A
        5 A A A A A A A A
        6 A A A A A A A A
        7 A A A A A A A A
        8 A A A A A A A A
        9 A A A A A A A A))
(define SB3 
  (local [(define l list)]
    (list 1 N123 N123 N1 N1 N1 N1 N1 N1
          2 N123 N123 N2 N2 N2 N2 N2 N2
          3 N123 N123 N3 N3 N3 N3 N3 N3
          4 N456 N456 N4 N4 N4 N4 N4 N4
          5 N456 N456 N5 N5 N5 N5 N5 N5
          6 N456 N456 N6 N6 N6 N6 N6 N6
          7 N789 N789 N7 N7 N7 N7 N7 N7
          8 N789 N789 N8 N8 N8 N8 N8 N8
          9 N789 N789 N9 N9 N9 N9 N9 N9)))
(define SB4-raw                ;easy
  (list 2 7 4 A 9 1 A A 5
        1 A A 5 A A A 9 A
        6 A A A A 3 2 8 A
        A A 1 9 A A A A 8
        A A 5 1 A A 6 A A
        7 A A A 8 A A A 3
        4 A 2 A A A A A 9
        A A A A A A A 7 A
        8 A A 3 4 9 A A A))
(define SB4s               ;solution to 4
  (list 2 7 4 8 9 1 3 6 5
        1 3 8 5 2 6 4 9 7
        6 5 9 4 7 3 2 8 1
        3 2 1 9 6 4 7 5 8
        9 8 5 1 3 7 6 4 2
        7 4 6 2 8 5 9 1 3
        4 6 2 7 5 8 1 3 9
        5 9 3 6 1 2 8 7 4
        8 1 7 3 4 9 5 2 6))
(define SB5-raw                ;hard
  (list 5 A A A A 4 A 7 A
        A 1 A A 5 A 6 A A
        A A 4 9 A A A A A
        A 9 A A A 7 5 A A
        1 8 A 2 A A A A A 
        A A A A A 6 A A A 
        A A 3 A A A A A 8
        A 6 A A 8 A A A 9
        A A 8 A 7 A A 3 1))
(define SB5s               ;solution to 5
  (list 5 3 9 1 6 4 8 7 2
        8 1 2 7 5 3 6 9 4
        6 7 4 9 2 8 3 1 5
        2 9 6 4 1 7 5 8 3
        1 8 7 2 3 5 9 4 6
        3 4 5 8 9 6 1 2 7
        9 2 3 5 4 1 7 6 8
        7 6 1 3 8 2 4 5 9
        4 5 8 6 7 9 2 3 1))
(define SB6-raw                ;hardest ever? (Dr Arto Inkala)
  (list A A 5 3 A A A A A 
        8 A A A A A A 2 A
        A 7 A A 1 A 5 A A 
        4 A A A A 5 3 A A
        A 1 A A 7 A A A 6
        A A 3 2 A A A 8 A
        A 6 A 5 A A A A 9
        A A 4 A A A A 3 A
        A A A A A 9 7 A A))
(define SB7-raw                ;no solution 
  (list 1 2 3 4 5 6 7 8 A 
        A A A A A A A A 2 
        A A A A A A A A 3 
        A A A A A A A A 4 
        A A A A A A A A 5
        A A A A A A A A 6
        A A A A A A A A 7
        A A A A A A A A 8
        A A A A A A A A 9))


;; -------------------
;; New Organizational Constants

(define ALL-POS (build-list 81 identity))

;; SMARTUNITS is a (listof (listof Unit)) that contains 81 (listof Unit)
;; Each (listof Unit) corresponds to a square on a Board or SmartBoard
;; and can be accessed using Pos. The (listof Unit) at a given Pos includes
;; all Units of which that Pos is a member.
(define SMARTUNITS
  (map (lambda (p)
         (filter (lambda (u)
                   (member? p u))
                 UNITS))
       ALL-POS))

;; NEIGHBOURS is a (listof (listof Pos)) that contains 81 (listof Pos)
;; Each (listof Pos) corresponds to a square on a Board or SmartBoard
;; and can be accessed by index using a Pos (I'll call the accessing Pos
;; Pos0). The (listof Pos) at a given Pos0 represents the list of all
;; positions that share at least one Unit with Pos0 (not including Pos0
;; itself).
(define NEIGHBORS
  (local [(define (get-neighbors p0)
            (foldr (lambda (p lop)
                     (if (or (= p p0) (member? p lop))  ;omit p0 and dupes
                         lop
                         (cons p lop)))
                   empty
                   (foldr append
                          empty
                          (list-ref SMARTUNITS p0))))]
  
    (map get-neighbors ALL-POS)))


;; =================
;; Functions:

(@htdf solve)
(@signature SmartBoard -> Board or false)
;; produces solved version of board using constraint sets, false if unsolvable
;; ASSUME: sb is valid and constrained SmartBoard
(check-expect (solve (prep-smartboard (bd->smartboard BD4))) BD4s)
(check-expect (solve (prep-smartboard (bd->smartboard BD5))) BD5s)
(check-expect (solve (prep-smartboard (bd->smartboard BD7))) false)

(@template encapsulated
           genrec arb-tree
           try-catch
           fn-composition)

(define (solve sb)
  (local [;;(@signature SmartBoard -> Smartboard or false)
          (define (fn-for-sb sb)
            (cond [(is-solved? sb) sb]  ;solved SmartBoard is eqv. to a Board
                  [(not-solvable? sb) false]  ;if any Squares are impossible
                  [else
                   (fn-for-losb (next-smartboards sb))]))

          ;;(@signature (listof SmartBoard) -> Smartboard or false)
          (define (fn-for-losb losb)
            (cond [(empty? losb) false]
                  [else
                   (local [(define try (fn-for-sb (first losb)))]
                     (if (not (false? try))
                         try
                         (fn-for-losb (rest losb))))]))]
     
    (fn-for-sb sb)))


(@htdf solve-steps)
(@signature SmartBoard -> (listof SmartBoard) or false)
;; produces list all next step boards towards solution, false if unsolvable
;; ASSUME: sb is a valid and constrained SmartBoard
(check-expect (solve-steps (prep-smartboard (list 5 3 9 A A A 8 7 2
                                                  8 1 2 7 5 3 6 9 4
                                                  6 7 4 9 2 8 3 1 5
                                                  2 9 6 A A 7 5 8 3
                                                  1 8 7 2 3 5 9 4 6
                                                  3 4 5 8 9 6 1 2 7
                                                  9 2 3 5 4 1 7 6 8
                                                  7 6 1 3 8 2 4 5 9
                                                  4 5 8 6 7 9 2 3 1)))
              (list (prep-smartboard (list 5 3 9 A A 4 8 7 2
                                           8 1 2 7 5 3 6 9 4
                                           6 7 4 9 2 8 3 1 5
                                           2 9 6 A A 7 5 8 3
                                           1 8 7 2 3 5 9 4 6
                                           3 4 5 8 9 6 1 2 7
                                           9 2 3 5 4 1 7 6 8
                                           7 6 1 3 8 2 4 5 9
                                           4 5 8 6 7 9 2 3 1))
                    (prep-smartboard (list 5 3 9 1 A 4 8 7 2
                                           8 1 2 7 5 3 6 9 4
                                           6 7 4 9 2 8 3 1 5
                                           2 9 6 A A 7 5 8 3
                                           1 8 7 2 3 5 9 4 6
                                           3 4 5 8 9 6 1 2 7
                                           9 2 3 5 4 1 7 6 8
                                           7 6 1 3 8 2 4 5 9
                                           4 5 8 6 7 9 2 3 1))
                    (prep-smartboard (list 5 3 9 1 6 4 8 7 2
                                           8 1 2 7 5 3 6 9 4
                                           6 7 4 9 2 8 3 1 5
                                           2 9 6 A A 7 5 8 3
                                           1 8 7 2 3 5 9 4 6
                                           3 4 5 8 9 6 1 2 7
                                           9 2 3 5 4 1 7 6 8
                                           7 6 1 3 8 2 4 5 9
                                           4 5 8 6 7 9 2 3 1))
                    (prep-smartboard (list 5 3 9 1 6 4 8 7 2
                                           8 1 2 7 5 3 6 9 4
                                           6 7 4 9 2 8 3 1 5
                                           2 9 6 4 A 7 5 8 3
                                           1 8 7 2 3 5 9 4 6
                                           3 4 5 8 9 6 1 2 7
                                           9 2 3 5 4 1 7 6 8
                                           7 6 1 3 8 2 4 5 9
                                           4 5 8 6 7 9 2 3 1))
                    (prep-smartboard (list 5 3 9 1 6 4 8 7 2
                                           8 1 2 7 5 3 6 9 4
                                           6 7 4 9 2 8 3 1 5
                                           2 9 6 4 1 7 5 8 3
                                           1 8 7 2 3 5 9 4 6
                                           3 4 5 8 9 6 1 2 7
                                           9 2 3 5 4 1 7 6 8
                                           7 6 1 3 8 2 4 5 9
                                           4 5 8 6 7 9 2 3 1))))
(check-expect (solve-steps (prep-smartboard (bd->smartboard BD7))) false)

(@template encapsulated
           genrec arb-tree
           try-catch
           fn-composition)

(define (solve-steps sb)
  (local [;;(@signature SmartBoard -> (listof Smartboard) or false)
          (define (fn-for-sb sb)
            (cond [(is-solved? sb) (list sb)]  ;solved SmartBoard eqv. to Board
                  [(not-solvable? sb) false]  ;if any Squares are impossible
                  [else
                   (local [(define try (fn-for-losb (next-smartboards sb)))]
                     (if (not (false? try))
                         (cons sb try)
                         false))]))

          ;;(@signature (listof SmartBoard) -> (listof SmartBoard) or false)
          (define (fn-for-losb losb)
            (cond [(empty? losb) false]
                  [else
                   (local [(define try (fn-for-sb (first losb)))]
                     (if (not (false? try))
                         try
                         (fn-for-losb (rest losb))))]))

          (define steps (fn-for-sb sb))]
     
    (if (false? steps)
        false
        (rest steps))))



;; -----------------
;; Helper Functions:

(@htdf is-solved?)
(@signature SmartBoard -> Boolean)
;; produce true if SmartBoard has only Val, not (listof Val)
;; ASSUME the given board is valid
(check-expect (is-solved? SB2) false)
(check-expect (is-solved? SB4-raw) false)
(check-expect (is-solved? SB4s) true)

(@template use-abstract-fn)
(define (is-solved? sb) (andmap integer? sb))


(@htdf not-solvable?)
(@signature SmartBoard -> Boolean)
;; produce true if any Square is an empty list (no valid options), else false
;; ASSUME: Combination of the non-list Val Squares in SmartBoard is valid
(check-expect (not-solvable? (cons (list 2) (rest SB4s))) false)
(check-expect (not-solvable? SB5s) false)
(check-expect (not-solvable? SB2) false)
(check-expect (not-solvable?
               (local [(define l list)]
                 (list 1 (ex (l 1 2 3)) (ex (l 1 2 3 9)) N1 N1 N1 N1 N1 N1
                       2 (ex (l 1 2 3)) (ex (l 1 2 3 9)) N2 N2 N2 N2 N2 N2
                       3 (ex (l 1 2 3)) (ex (l 1 2 3 9)) N3 N3 N3 N3 N3 N3
                       4 (ex (l 4 5 6)) (ex (l 4 5 6 9)) N4 N4 N4 N4 N4 N4
                       5 (ex (l 4 5 6)) (ex (l 4 5 6 9)) N5 N5 N5 N5 N5 N5
                       6 (ex (l 4 5 6)) (ex (l 4 5 6 9)) N6 N6 N6 N6 N6 N6
                       7 (ex (l 7 8 9)) (ex (l 7 8 9))   N7 N7 N7 N7 N7 N7
                       8 (ex (l 7 8 9)) (ex (l 7 8 9))   N8 N8 N8 N8 N8 N8
                       E (ex (l 7 8 9))      9           N9 N9 N9 N9 N9 N9)))
              true)

(@template use-abstract-fn)
(define (not-solvable? sb) (ormap empty? sb))


(@htdf bd->smartboard)
(@signature Board -> SmartBoard)
;; produce an equivalent SmartBoard by changing each false in Board to ALL-VALS
(check-expect (bd->smartboard BD1) SB1)
(check-expect (bd->smartboard BD2) SB2-raw)
(check-expect (bd->smartboard BD4) SB4-raw)

(@template use-abstract-fn)
(define (bd->smartboard bd)
  (map (lambda (v) (if (false? v)
                       ALL-VALS
                       v))
       bd))


(@htdf prep-smartboard)
(@signature SmartBoard -> SmartBoard)
;; produce SmartBoard with all non-legal Val in (listof Val) Squares removed
(check-expect (prep-smartboard SB2-raw) SB2)
(check-expect (prep-smartboard SB3-raw) SB3)
(check-expect (prep-smartboard SB1) SB1)
(check-expect (prep-smartboard SB2) SB2)
(check-expect (prep-smartboard SB5s) SB5s)

(@template use-abstract-fn)
(define (prep-smartboard sb)
  (foldr (lambda (p sb)
           (local [(define s (list-ref sb p))]
             (if (integer? s)
                 (eliminate-options s p sb)
                 sb)))
         sb
         ALL-POS))


(@htdf eliminate-options)
(@signature Val Pos SmartBoard -> SmartBoard)
;; produce SmartBoard with Val removed from all (listof Val) NEIGHBORS of Pos
(check-expect (eliminate-options 2 10 SB1)
              (list N2 N2 N2 A  A  A  A  A  A
                    N2 A  N2 N2 N2 N2 N2 N2 N2
                    N2 N2 N2 A  A  A  A  A  A
                    A  N2 A  A  A  A  A  A  A
                    A  N2 A  A  A  A  A  A  A
                    A  N2 A  A  A  A  A  A  A
                    A  N2 A  A  A  A  A  A  A
                    A  N2 A  A  A  A  A  A  A
                    A  N2 A  A  A  A  A  A  A))
(check-expect (eliminate-options 9 72 SB3-raw)
              (list 1 A  A  A  A  A  A  A  A
                    2 A  A  A  A  A  A  A  A
                    3 A  A  A  A  A  A  A  A
                    4 A  A  A  A  A  A  A  A
                    5 A  A  A  A  A  A  A  A
                    6 A  A  A  A  A  A  A  A
                    7 N9 N9 A  A  A  A  A  A
                    8 N9 N9 A  A  A  A  A  A
                    9 N9 N9 N9 N9 N9 N9 N9 N9))
;(define (eliminate-options val pos sb) sb)  ;stub

(@template use-abstract-fn)
(define (eliminate-options val p0 sb)
  (local [(define this-neighbors (list-ref NEIGHBORS p0))
          (define (remove-val lov)
            (filter (lambda (v) (not (= v val)))
                    lov))]
    
    (map (lambda (p)
           (local [(define sq (list-ref sb p))]
             (if (and (list? sq)
                      (member p this-neighbors))
                 (remove-val sq)
                 sq)))
         ALL-POS)))


(@htdf next-smartboards)
(@signature SmartBoard -> (listof SmartBoard))
;; produce next boards by filling most constrained space with each Val option
;; ASSUME: there is at least one unfilled Square such that (list? sq) is true
;; ASSUME: no Squares are impossible i.e. hold an empty (listof Val)
(check-expect (next-smartboards
               (local [(define l list)]
                 (list 1     (ex (l 1 2 3)) (ex (l 1 2 3)) N1 N1 N1 N1 N1 N1
                       2     (ex (l 1 2 3)) (ex (l 1 2 3)) N2 N2 N2 N2 N2 N2
                       3     (ex (l 1 2 3)) (ex (l 1 2 3)) N3 N3 N3 N3 N3 N3
                       4     (ex (l 4 5 6)) (ex (l 4 5 6)) N4 N4 N4 N4 N4 N4
                       5     (ex (l 4 5 6)) (ex (l 4 5 6)) N5 N5 N5 N5 N5 N5
                       6     (ex (l 4 5 6)) (ex (l 4 5 6)) N6 N6 N6 N6 N6 N6
                       7     (ex (l 7 8))   (ex (l 7 8))   N7 N7 N7 N7 N7 N7
                       8     (ex (l 7 8))   (ex (l 7 8))   N8 N8 N8 N8 N8 N8
                       (l 9) (ex (l 7 8))   (ex (l 7 8))   A  A  A  A  A  A)))
              (list 
               (local [(define l list)]
                 (list 1 (ex (l 1 2 3)) (ex (l 1 2 3)) N1 N1 N1 N1 N1 N1
                       2 (ex (l 1 2 3)) (ex (l 1 2 3)) N2 N2 N2 N2 N2 N2
                       3 (ex (l 1 2 3)) (ex (l 1 2 3)) N3 N3 N3 N3 N3 N3
                       4 (ex (l 4 5 6)) (ex (l 4 5 6)) N4 N4 N4 N4 N4 N4
                       5 (ex (l 4 5 6)) (ex (l 4 5 6)) N5 N5 N5 N5 N5 N5
                       6 (ex (l 4 5 6)) (ex (l 4 5 6)) N6 N6 N6 N6 N6 N6
                       7 (ex (l 7 8 9)) (ex (l 7 8 9)) N7 N7 N7 N7 N7 N7
                       8 (ex (l 7 8 9)) (ex (l 7 8 9)) N8 N8 N8 N8 N8 N8
                       9 (ex (l 7 8 9)) (ex (l 7 8 9)) N9 N9 N9 N9 N9 N9))))
(check-expect (next-smartboards SB2)
              (list (eliminate-options 4 9 (append (take SB2 9)
                                                   (list 4)
                                                   (drop SB2 (add1 9))))
                    (eliminate-options 5 9 (append (take SB2 9)
                                                   (list 5)
                                                   (drop SB2 (add1 9))))
                    (eliminate-options 6 9 (append (take SB2 9)
                                                   (list 6)
                                                   (drop SB2 (add1 9))))
                    (eliminate-options 7 9 (append (take SB2 9)
                                                   (list 7)
                                                   (drop SB2 (add1 9))))
                    (eliminate-options 8 9 (append (take SB2 9)
                                                   (list 8)
                                                   (drop SB2 (add1 9))))
                    (eliminate-options 9 9 (append (take SB2 9)
                                                   (list 9)
                                                   (drop SB2 (add1 9))))))

(@template fn-composition)
(define (next-smartboards sb)
  (fill-square-w-options sb (most-constrained-pos sb)))


(@htdf most-constrained-pos)
(@signature SmartBoard -> Pos)
;; produce Pos of first Square among all unfilled ones with fewest Val options
;; ASSUME: SmartBoard has at least one unfilled Square, no impossible Squares
(check-expect (most-constrained-pos SB1) 0)
(check-expect (most-constrained-pos SB2) 9)
(check-expect (most-constrained-pos SB3) 1)
(check-expect (most-constrained-pos
               (local [(define l list)]
                 (list 1     (ex (l 1 2 3)) (ex (l 1 2 3)) N1 N1 N1 N1 N1 N1
                       2     (ex (l 1 2 3)) (ex (l 1 2 3)) N2 N2 N2 N2 N2 N2
                       3     (ex (l 1 2 3)) (ex (l 1 2 3)) N3 N3 N3 N3 N3 N3
                       4     (ex (l 4 5 6)) (ex (l 4 5 6)) N4 N4 N4 N4 N4 N4
                       5     (ex (l 4 5 6)) (ex (l 4 5 6)) N5 N5 N5 N5 N5 N5
                       6     (ex (l 4 5 6)) (ex (l 4 5 6)) N6 N6 N6 N6 N6 N6
                       7     (ex (l 7 8))   (ex (l 7 8))   N7 N7 N7 N7 N7 N7
                       8     (ex (l 7 8))   (ex (l 7 8))   N8 N8 N8 N8 N8 N8
                       (l 9) (ex (l 7 8))   (ex (l 7 8))   A  A  A  A  A  A)))
              72)

(@template SmartBoard accumulator)
(define (most-constrained-pos sb)
  ;; min is Number       ; number of Val options in most constrained Square
  ;; min-p is Pos|false  ; position of 1st Square with min Val options if found
  ;; p is Pos            ; current position in list traversal
  (local [(define (fn-for-sb sb min min-p p)
            (cond [(empty? sb) min-p]
                  [else
                   (local [(define sq (first sb))]
                     (cond [(list? sq)
                            (if (< (length sq) min)
                                (fn-for-sb (rest sb) (length sq) p (add1 p))
                                (fn-for-sb (rest sb) min min-p (add1 p)))]
                           [else
                            (fn-for-sb (rest sb) min min-p (add1 p))]))]))]

    (fn-for-sb sb +inf.0 false 0)))


(@htdf fill-square-w-options)
(@signature SmartBoard Pos -> (listof SmartBoard))
;; produce SmartBoards by filling Square with Vals and revising neighbor options
;; ASSUME Pos corresponds to an unfilled, non-impossible Square of SmartBoard
(check-expect
 (fill-square-w-options
  (local [(define l list)]
    (list 1     (ex (l 1 2 3)) (ex (l 1 2 3)) N1 N1 N1 N1 N1 N1
          2     (ex (l 1 2 3)) (ex (l 1 2 3)) N2 N2 N2 N2 N2 N2
          3     (ex (l 1 2 3)) (ex (l 1 2 3)) N3 N3 N3 N3 N3 N3
          4     (ex (l 4 5 6)) (ex (l 4 5 6)) N4 N4 N4 N4 N4 N4
          5     (ex (l 4 5 6)) (ex (l 4 5 6)) N5 N5 N5 N5 N5 N5
          6     (ex (l 4 5 6)) (ex (l 4 5 6)) N6 N6 N6 N6 N6 N6
          7     (ex (l 7 8))   (ex (l 7 8))   N7 N7 N7 N7 N7 N7
          8     (ex (l 7 8))   (ex (l 7 8))   N8 N8 N8 N8 N8 N8
          (l 9) (ex (l 7 8))   (ex (l 7 8))   A  A  A  A  A  A))
  72)
 (list (local [(define l list)]
         (list 1 (ex (l 1 2 3)) (ex (l 1 2 3)) N1 N1 N1 N1 N1 N1
               2 (ex (l 1 2 3)) (ex (l 1 2 3)) N2 N2 N2 N2 N2 N2
               3 (ex (l 1 2 3)) (ex (l 1 2 3)) N3 N3 N3 N3 N3 N3
               4 (ex (l 4 5 6)) (ex (l 4 5 6)) N4 N4 N4 N4 N4 N4
               5 (ex (l 4 5 6)) (ex (l 4 5 6)) N5 N5 N5 N5 N5 N5
               6 (ex (l 4 5 6)) (ex (l 4 5 6)) N6 N6 N6 N6 N6 N6
               7 (ex (l 7 8 9)) (ex (l 7 8 9)) N7 N7 N7 N7 N7 N7
               8 (ex (l 7 8 9)) (ex (l 7 8 9)) N8 N8 N8 N8 N8 N8
               9 (ex (l 7 8 9)) (ex (l 7 8 9)) N9 N9 N9 N9 N9 N9))))
(check-expect (fill-square-w-options SB2 9)
              (list (eliminate-options 4 9 (append (take SB2 9)
                                                   (list 4)
                                                   (drop SB2 (add1 9))))
                    (eliminate-options 5 9 (append (take SB2 9)
                                                   (list 5)
                                                   (drop SB2 (add1 9))))
                    (eliminate-options 6 9 (append (take SB2 9)
                                                   (list 6)
                                                   (drop SB2 (add1 9))))
                    (eliminate-options 7 9 (append (take SB2 9)
                                                   (list 7)
                                                   (drop SB2 (add1 9))))
                    (eliminate-options 8 9 (append (take SB2 9)
                                                   (list 8)
                                                   (drop SB2 (add1 9))))
                    (eliminate-options 9 9 (append (take SB2 9)
                                                   (list 9)
                                                   (drop SB2 (add1 9))))))
;(define (fill-square-w-options sb p0) empty)  ;stub

(@template use-abstract-fn)
(define (fill-square-w-options sb p0)
  (local [(define option-list (list-ref sb p0))
          ;;(@signature Val -> SmartBoard)
          (define (put-val v)
            (append (take sb p0)
                    (list v)
                    (drop sb (add1 p0))))
          ;;(@signature Val -> SmartBoard)
          (define (fill-val-and-clean v)
            (eliminate-options v p0 (put-val v)))]

    (map fill-val-and-clean
         option-list)))



;; -------------------------------------------------------
;; ==================== WORLD PROGRAM ====================
;; -------------------------------------------------------
(require 2htdp/image)
(require 2htdp/universe)

;; Playable Sudoku

(@htdw Game)

;; =================
;; Constants:

;; --- Colors ---
(define BASE-NUM-COLOR "black")
(define USER-NUM-COLOR "navy")
(define TINY-NUM-COLOR "sky blue")
(define NOPE-NUM-COLOR "crimson")
(define HINT-NUM-COLOR "forest green")

(define SML-GRID-COLOR "gray")
(define BIG-GRID-COLOR "dark gray")

(define SQ-COLOR "white")


;; --- Sizes ---
(define CELL-W 16)
(define SQUARE-W (* 3 CELL-W))
(define BOARD-W (* 9 SQUARE-W))

(define TOTAL-H (* 11 SQUARE-W))
(define TOTAL-W (* 16 SQUARE-W))

(define TINY-TEXT-SIZE (floor (* 0.8 CELL-W)))
(define SQUARE-TEXT-SIZE (floor (* 0.8 SQUARE-W)))

(define SML-LINE-SIZE 2)
(define BIG-LINE-SIZE 4)
(define SML-LINE (pen SML-GRID-COLOR SML-LINE-SIZE "solid" "round" "round"))
(define BIG-LINE (pen BIG-GRID-COLOR BIG-LINE-SIZE "solid" "round" "round"))


;; --- Components ---
(define MTS (empty-scene TOTAL-W TOTAL-H "white"))

(define SQUARE (square SQUARE-W "outline" SML-LINE))
(define BOX (square (* 3 SQUARE-W) "outline" BIG-LINE))
(define SQ-GRID (above (beside SQUARE SQUARE SQUARE)
                       (beside SQUARE SQUARE SQUARE)
                       (beside SQUARE SQUARE SQUARE)))
(define BIG-GRID (above (beside BOX BOX BOX)
                        (beside BOX BOX BOX)
                        (beside BOX BOX BOX)))
(define MTBOARD (overlay BIG-GRID
                         (above (beside SQ-GRID SQ-GRID SQ-GRID)
                                (beside SQ-GRID SQ-GRID SQ-GRID)
                                (beside SQ-GRID SQ-GRID SQ-GRID))))
(define TINY-CELL (square CELL-W "solid" "transparent"))
(define CHOICES (map (λ (n) (overlay (text (number->string n)
                                           TINY-TEXT-SIZE
                                           TINY-NUM-COLOR)
                                     TINY-CELL))
                     ALL-VALS))


;; =================
;; Data definitions:

(@htdd Mode)
;; Mode is one of:
;;   "choose"
;;   "erase"
;;   "solve"
;; INTERP. Current selected game mode.
;; "choose" allows to select number values for empty squares
;; "erase" allows to remove previously-added numbers
;; "solve" disables board interactions and shows steps for an automatic solve
(define CHOOSE "choose")
(define ERASE "erase")
(define SOLVE "solve")

(define (fn-for-mode m)
  (cond [(string=? m CHOOSE) (...)]
        [(string=? m ERASE)  (...)]
        [(string=? m SOLVE)  (...)]))



(@htdd Options)
(define-struct ops [showchoices showerrors])
;; Options is (make-ops Boolean Boolean)
;; INTERP. The state of current selections for game options
;;   showchoices is true if allowed values will be shown in empty squares
;;   showerrors  is true if numbers making a game unsolvable are highlighted
(define OP00 (make-ops false false))
(define OP01 (make-ops false true))
(define OP10 (make-ops true  false))

(define (fn-for-ops o)
  (... (ops-showchoices o)
       (ops-showerrors o)))



(@htdd Game)
(define-struct game [initial current solution
                             prev next errors
                             mode options])
;; Game is (make-game SmartBoard SmartBoard SmartBoard
;;                    (listof SmartBoard) (listof SmartBoard) (listof Pos)
;;                    Mode Options)
;; INTERP. the state of a playable Sudoku game
;;   initial  - SmartBoard of the starting board state
;;   current  - SmartBoard of the current board state
;;   solution - SmartBoard|false
;;              solved state of the first solution found to current board
;;              OR last known possible solution prior to recent errors
;;              OR false if initial state has no solutions
;;   prev     - list of SmartBoards for the board states of all steps
;;              taken from initial to just before current
;;   next     - list of Smartboards for all correct steps after current until
;;              a correct solution is reached
;;   mode     - current game mode Mode for interactions with the sudoku game
;;   options  - state of current selections for game options

(define EASY (make-game (prep-smartboard SB4-raw)  ;initial
                        (prep-smartboard SB4-raw)  ;current
                        BD4s                  ;solution
                        empty                 ;prev
                        (solve-steps (prep-smartboard SB4-raw))  ;next
                        empty                 ;errors
                        CHOOSE                ;mode
                        OP00))                ;options
(define HARD (make-game (prep-smartboard SB5-raw)
                        (prep-smartboard SB5-raw)
                        BD5s
                        empty
                        (solve-steps (prep-smartboard SB5-raw))
                        empty
                        CHOOSE
                        OP00))



;; =================
;; Default Constants:
(define DEFAULT-MODE CHOOSE)
(define DEFAULT-OPS OP00)



;; =================
;; Functions:

(@htdf main)
(@signature Game -> Game)
;; start the world with (main EASY)
;;                      (main MED)
;;                      (main HARD) or
;;                      (main (bd->game <Board>))
;; 

(@template htdw-main)

(define (main g)
  (big-bang g                   ; Game
    (on-tick   tock    0.25)    ; Game -> Game
    (to-draw   render)          ; Game -> Image
    (on-mouse  handle-mouse)))  ; Game Integer Integer MouseEvent -> Game
;(on-key    ...)))  ; Game KeyEvent -> Game


(@htdf tock)
(@signature Game -> Game)
;; produce the next sudoku board during automatic solving 
;!!!
(define (tock g) g)  ;stub

(@template Game)
#;
(define (tock g)
  (cond [(string=? (game-mode g) SOLVE)
         (solve-step g)]
        [else g]))


(@htdf render)
(@signature Game -> Image)
;; render ... 
;!!!
;(define (render g) empty-image)  ;stub

(@template fn-composition)
(define (render g)
  (overlay (beside (overlay MTBOARD
                            (render-board g))
                   (rectangle SQUARE-W 0 "solid" "white")
                   (render-buttons g))))


(@htdf handle-mouse)
(@signature Game Integer Integer MouseEvent -> Game)
;; update game state based on mouse input to board or buttons
;!!!
(define (handle-mouse g x y me) g)  ;stub


(@template MouseEvent)
#;
(define (handle-mouse g x y me)
  (cond [(mouse=? me "button-down") (... g x y)]
        [else
         (... g x y)]))  ;hover behavior?



;; -----Helper Functions-----

(@htdf bd->game)
(@signature Board -> Game)
;; produce the starting state of a playable Sudoku game from a given Board
(check-expect (bd->game BD4) EASY)
(check-expect (bd->game BD5) HARD)

;(define (bd->game bd) EASY)  ;stub

(@template fn-composition)

(define (bd->game bd)
  (local [(define sb (prep-smartboard (bd->smartboard bd)))]
    (make-game sb                ;initial
               sb                ;current
               (solve sb)        ;solution
               empty             ;prev
               (solve-steps sb)  ;next
               empty             ;errors
               DEFAULT-MODE      ;mode
               DEFAULT-OPS)))    ;options


(@htdf solve-step)
(@signature Game -> Game)
;; produce updated game after taking one next step towards known solution
;!!!
(define (solve-step g) g)  ;stub

(@template Game)
#;
(define (solve-step)
  (cond [;; Errors present - remove one error
         (not (empty? (game-errors g)))
         (make-game (game-initial g)
                    (game-current g)
                    (game-solution g)
                    (game-prev g)
                    (game-next g)
                    (game-errors g)
                    (game-mode g)
                    (game-options g))]
        ;; No errors - take next step to solve
        [(not (empty? (game-next g)))
         (make-game (game-initial g)
                    (first (game-next g))
                    (game-solution g)
                    (cons (game-current g) (game-prev g))
                    (rest (game-next g))
                    (game-errors g)
                    (game-mode g)
                    (game-options g))]
        ;; Finished - switch from SOLVE mode to CHOOSE
        [else
         (make-game (game-initial g)
                    (game-current g)
                    (game-solution g)
                    (game-prev g)
                    (game-next g)
                    (game-errors g)
                    CHOOSE
                    (game-options g))]))


(@htdf render-board)
(@signature Game -> Image)
;; produce a rendering of the current state of the sudoku grid
;!!!
;(define (render-board g) empty-image)  ;stub

(@template use-abstract-fn fn-composition)
(define (render-board g)
  (local [(define board (game-current g))

          (define (split-rows losq0)
            ;; n is Natural  ; context accumululator for how many more
            ;;                 list items to grab from losq0 before splitting
            ;; rowsf is (listof Square)  ;context accumulator for in-progress
            ;;                            row item sublist
            (local [(define (split-rows losq n rowsf)
                      (cond [(empty? losq) (list rowsf)]
                            [else
                             (if (zero? n)
                                 (append (list rowsf)
                                         (split-rows losq 9 empty))
                                 (split-rows (rest losq)
                                             (sub1 n)
                                             (append rowsf
                                                     (list (first losq)))))]))]
              
              (split-rows losq0 9 empty)))

          ;; ASSUME: losq has 9 items
          (define (make-row losq)
            (foldl (λ (sq row)
                     (beside row (render-square sq)))
                   empty-image
                   losq))
          
          ;; produce board render from list of 9 row images
          (define (join-rows loi)
            (foldl (λ (row bd)
                     (above bd row))
                   empty-image
                   loi))]
    
    (join-rows (map make-row
                    (split-rows (game-current g))))))


(@htdf render-square)
(@signature Square -> Image)
;; produce image representing a single square in sudoku grid
(check-expect (render-square 5) (overlay ))
(define (render-square sq) empty-image)  ;stub

(@template Square)


(@htdf render-buttons)
(@signature Game -> Image)
;; produce image of buttons in the GUI in their current state
;!!!
(define (render-buttons g) empty-image)


